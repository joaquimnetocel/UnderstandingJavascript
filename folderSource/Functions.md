# FUNCTIONS

QUITE OFTEN WE NEED TO PERFORM A SIMILAR ACTION IN MANY PLACES OF THE SCRIPT. FUNCTIONS ARE THE MAIN “BUILDING BLOCKS” OF THE PROGRAM. THEY ALLOW THE CODE TO BE CALLED MANY TIMES WITHOUT REPETITION.

## FUNCTION DECLARATION

TO CREATE A FUNCTION WE CAN USE A FUNCTION DECLARATION. IT LOOKS LIKE THIS:

```javascript
// FUNCTION DEFINITION
function functionSayHello(){
    const stringName = "JOHN";
    console.log("HELLO " + stringName);
};
/////
// FUNCTION EXECUTION
functionSayHello(); // SHOWS: HELLO JOHN
functionSayHello(); // SHOWS: HELLO JOHN
functionSayHello(); // SHOWS: HELLO JOHN
/////
```

THE CALL `functionSayHello()` EXECUTES THE CODE OF THE FUNCTION. THIS EXAMPLE CLEARLY DEMONSTRATES ONE OF THE MAIN PURPOSES OF FUNCTIONS: TO AVOID CODE DUPLICATION.

## PARAMETERS

FUNCTIONS CAN ALSO DEPEND ON PARAMETERS THAT CAN ASSUME DIFFERENT VALUES WHEN THE FUNCTION IS EXECUTED. IN THE EXAMPLE BELOW, THE FUNCTION HAS TWO PARAMETERS: `parSize` AND `parColor`.

```javascript
// FUNCTION DEFINITION
function functionSaySomethingAboutTheHouse(parSize, parColor){
    console.log(`THE HOUSE IS ${parSize} AND ${parColor}.`);
};
/////
// FUNCTION EXECUTIONS
functionSaySomethingAboutTheHouse("SMALL", "GREEN"); // SHOWS: THE HOUSE IS SMALL AND GREEN.
functionSaySomethingAboutTheHouse("BIG", "WHITE"); // SHOWS: THE HOUSE IS BIG AND WHITE.
functionSaySomethingAboutTheHouse("SMALL", "RED"); // SHOWS: THE HOUSE IS SMALL AND RED.
/////
```

## ARGUMENTS

WHEN A VALUE IS PASSED AS A FUNCTION PARAMETER, IT’S ALSO CALLED AN ARGUMENT. IN OTHER WORDS, TO PUT THESE TERMS STRAIGHT:

* A PARAMETER IS THE VARIABLE LISTED INSIDE THE PARENTHESES IN THE FUNCTION DECLARATION (IT’S A DECLARATION TIME TERM).
* AN ARGUMENT IS THE VALUE THAT IS PASSED TO THE FUNCTION WHEN IT IS CALLED (IT'S A CALL TIME TERM).

WE DECLARE FUNCTIONS LISTING THEIR PARAMETERS, THEN CALL THEM PASSING ARGUMENTS.

IN THE EXAMPLE ABOVE, ONE MIGHT SAY THAT THE FUNCTION IS DECLARED WITH TWO PARAMETERS `parSize` AND `parColor`, THEN CALLED WITH THE ARGUMENTS: "SMALL", "GREEN", "BIG", "WHITE" AND "RED".

## DEFAULT VALUES

IF A FUNCTION IS CALLED, BUT AN ARGUMENT IS NOT PROVIDED, THEN THE CORRESPONDING VALUE BECOMES `undefined`. FOR INSTANCE, THE AFOREMENTIONED FUNCTION `functionSaySomethingAboutTheHouse(parSize, parColor)` CAN BE CALLED WITH A SINGLE ARGUMENT:

```javascript
// FUNCTION DEFINITION
function functionSaySomethingAboutTheHouse(parSize, parColor){
    console.log(`THE HOUSE IS ${parSize} AND ${parColor}.`);
};
/////
// FUNCTION EXECUTION
functionSaySomethingAboutTheHouse("BIG"); // SHOWS: THE HOUSE IS BIG AND undefined.
/////
```

WE CAN SPECIFY THE SO-CALLED "DEFAULT" (TO USE IF OMITTED) VALUE FOR A PARAMETER IN THE FUNCTION DECLARATION:

```javascript
// FUNCTION DEFINITION
function functionSaySomethingAboutTheHouse(parSize="HUGE", parColor="WHITE"){
    console.log(`THE HOUSE IS ${parSize} AND ${parColor}.`);
};
/////
// FUNCTION EXECUTION
functionSaySomethingAboutTheHouse("SMALL"); // SHOWS: THE HOUSE IS SMALL AND WHITE.
/////
```

THE DEFAULT VALUE ALSO JUMPS IN IF THE PARAMETER EXISTS, BUT STRICTLY EQUALS UNDEFINED, LIKE THIS:

```javascript
// FUNCTION EXECUTION
functionSaySomethingAboutTheHouse(undefined, "RED"); // SHOWS: THE HOUSE IS HUGE AND RED.
/////
```

## RETURN

A FUNCTION CAN RETURN A VALUE BACK INTO THE CALLING CODE AS THE RESULT. THE SIMPLEST EXAMPLE WOULD BE A FUNCTION THAT SUMS TWO VALUES:

```javascript
function functionSum(parNumber1, parNumber2){
    return parNumber1 + parNumber2;
};
const numberResult = functionSum(2,4);
console.log(numberResult); // SHOWS: 6.
```

THE DIRECTIVE RETURN CAN BE IN ANY PLACE OF THE FUNCTION. WHEN THE EXECUTION REACHES IT, THE FUNCTION STOPS, AND THE VALUE IS RETURNED TO THE CALLING CODE (ASSIGNED TO RESULT ABOVE).

THERE MAY BE MANY OCCURRENCES OF RETURN IN A SINGLE FUNCTION. FOR INSTANCE:

```javascript
function functionIsExpensive(parPrice) {
    if (parPrice > 100) {
        return true;
    } 
    return false;
}

const numberPrice = 80;

if ( functionIsExpensive(numberPrice) ) {
    console.log("NO, THANKS!"); // THIS LINE IS NOT EXECUTTED.
} else {
    console.log("GREAT! I WILL BUY."); // SHOWS: GREAT! I WILL BUY.
}
```

## NO RETURNS

A FUNCTION WITH AN EMPTY RETURN OR WITHOUT IT RETURNS `undefined`. IN OTHER WORDS, IF A FUNCTION DOES NOT RETURN A VALUE, IT IS THE SAME AS IF IT RETURNS `undefined`:

```javascript
function functionDoNothing() {}
console.log( functionDoNothing() ); // SHOWS: undefined
```

AN EMPTY RETURN IS ALSO THE SAME AS RETURN `undefined`:

```javascript
function functionDoNothing() {
    return;
}
console.log( functionDoNothing() ); // SHOWS: undefined
```

## LOCAL VARIABLES

A VARIABLE DECLARED INSIDE A FUNCTION IS ONLY VISIBLE INSIDE THAT FUNCTION. FOR EXAMPLE:

```javascript
// FUNCTION DEFINITION
function functionShowMessage() {
    const stringMessage = "HELLO!"; // LOCAL VARIABLE
    console.log(stringMessage);
}
// FUNCTION EXECUTION
functionShowMessage(); // SHOWS: HELLO!
/////
console.log(stringMessage); // ERROR: THE VARIABLE I LOCAL TO THE FUNCTION.
```

## OUTER VARIABLES

A FUNCTION CAN ACCESS AN OUTER VARIABLE AS WELL, FOR EXAMPLE:

```javascript
let stringName = "JOHN";

function functionShowMessage() {
    let stringMessage = "HELLO " + stringName;
    console.log(stringMessage);
}
functionShowMessage(); // SHOWS: HELLO JOHN
```

THE FUNCTION HAS FULL ACCESS TO THE OUTER VARIABLE. IT CAN MODIFY IT AS WELL. FOR INSTANCE:

```javascript
let stringName = "JOHN";

function functionShowMessage() {
    stringName = "BOB"; // CHANGED THE OUTER VARIABLE.
    console.log("HELLO " + stringName);
}

console.log(stringName); // SHOWS: JOHN
functionShowMessage(); // SHOWS: HELLO BOB
console.log(stringName); // SHOWS: BOB
```

THE OUTER VARIABLE IS ONLY USED IF THERE'S NO LOCAL ONE. IF A SAME-NAMED VARIABLE IS DECLARED INSIDE THE FUNCTION THEN IT SHADOWS THE OUTER ONE. FOR INSTANCE, IN THE CODE BELOW THE FUNCTION USES THE LOCAL stringNAME. THE OUTER ONE IS IGNORED:

```javascript
let stringName = "JOHN"; // GLOBAL VARIABLE

function functionShowMessage() {
    let stringName = "BOB"; // LOCAL VARIABLE
    console.log("HELLO " + stringName); // SHOWS: HELLO BOB
}

functionShowMessage(); // THE FUNCTION WILL CREATE AND USE ITS OWN stringName.

console.log(stringName); // SHOWS JOHN, UNCHANGED, THE FUNCTION DID NOT ACCESS THE OUTER VARIABLE.
```

VARIABLES DEFINED OUTSIDE OF FUNCTIONS ARE CALLED **GLOBAL**. IT'S A GOOD PRACTICE TO MINIMIZE THE USE OF GLOBAL VARIABLES. MODERN CODE HAS FEW OR NO GLOBALS. MOST VARIABLES RESIDE IN THEIR FUNCTIONS.

## FUNCTION EXPRESSION

THE SYNTAX THAT WE USED BEFORE IS CALLED A FUNCTION DECLARATION. THERE IS ANOTHER SYNTAX FOR CREATING A FUNCTION THAT IS CALLED A FUNCTION EXPRESSION. IT ALLOWS US TO CREATE A NEW FUNCTION IN THE MIDDLE OF ANY EXPRESSION. FOR EXAMPLE:

```javascript
// FUNCTION DEFINITION
const functionSayHello = function(){
    console.log("HELLO!");
};
/////
// FUNCTION EXECUTION
functionSayHello(); // SHOWS: HELLO!
/////
```

PLEASE NOTE, THERE IS NO NAME AFTER THE FUNCTION KEYWORD. OMITTING A NAME IS ALLOWED FOR FUNCTION EXPRESSIONS. HERE WE IMMEDIATELY ASSIGN IT TO A VARIABLE. THE VARIABLE NAME CAN THEN BE USED TO CALL THE FUNCTION.

## ARROW FUNCTION

THERE IS ANOTHER VERY SIMPLE AND CONCISE SYNTAX FOR CREATING FUNCTIONS, THAT IS OFTEN BETTER THAN FUNCTION EXPRESSIONS. IT IS CALLED "ARROW FUNCTIONS". FIRST LET'S SEE A SIMPLE FUNCTION EXPRESSION USED TO SQUARE A NUMBER:

```javascript
const functionSquare = (parNumber)=>{
    return parNumber * parNumber;
};
console.log( functionSquare(3) ); // 9
console.log( functionSquare(4) ); // 16
```

NOW, LET'S SEE HOW THIS COULD BE DONE WITH ARROW FUNCTIONS:

```javascript
const functionSquare = parNumber => parNumber * parNumber;
console.log( functionSquare(3) ); // 9
console.log( functionSquare(4) ); // 16
```

AS WEE CAN SEE, ARROW FUNCTIONS CAN BE USED IN THE SAME WAY AS FUNCTION EXPRESSIONS. THEY MAY APPEAR UNFAMILIAR AND NOT VERY READABLE AT FIRST, BUT THAT QUICKLY CHANGES AS THE EYES GET USED TO THE STRUCTURE. THEY ARE VERY CONVENIENT FOR SIMPLE ONE-LINE ACTIONS, WHEN WE ARE JUST TOO LAZY TO WRITE MANY WORDS.

HERE WE PRAISED ARROW FUNCTIONS FOR BREVITY. BUT THAT'S NOT ALL! ARROW FUNCTIONS HAVE OTHER INTERESTING FEATURES. TO STUDY THEM IN-DEPTH, CLICK [HERE](https://javascript.info/arrow-functions).

## MULTILINE ARROW FUNCTIONS

THE ARROW FUNCTIONS THAT WE'VE SEEN SO FAR WERE VERY SIMPLE. SOMETIMES WE NEED A MORE COMPLEX FUNCTION, WITH MULTIPLE EXPRESSIONS AND STATEMENTS. IN THAT CASE, WE CAN ENCLOSE THEM IN CURLY BRACES. THE MAJOR DIFFERENCE IS THAT CURLY BRACES REQUIRE A RETURN WITHIN THEM TO RETURN A VALUE (JUST LIKE A REGULAR FUNCTION DOES). LIKE THIS:

```javascript
const functionSum = (parNumber1, parNumber2) => { // THE CURLY BRACE OPENS A MULTILINE FUNCTION
    const numberResult = parNumber1 + parNumber2;
    return numberResult; // AS WE USED CURLY BRACES, THEN WE NEED AN EXPLICIT "RETURN".
};
console.log( functionSum(1, 2) ); // SHOWS: 3
```

## FUNCTION DECLARATIONS VERSUS FUNCTION EXPRESSIONS

CLICK [HERE](./FunctionDeclarationVersusFunctionExpression.md) TO LEARN MORE ABOUT THE DIFFERENCES BETWEEN FUNCTION DECLARATIONS AND FUNCTION EXPRESSIONS.
